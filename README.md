

![Screenshot_2024-01-29-19-19-28-082_com example cfttest2024](https://github.com/OrionDevelopNSK/CFTTest2024/assets/86998536/cf54adb0-1ec4-4249-a11e-f98db646761e)
![Screenshot_2024-01-29-19-19-44-652_com example cfttest2024](https://github.com/OrionDevelopNSK/CFTTest2024/assets/86998536/e1a29ddf-7fad-4495-9cc9-dee30901fa1d)





PS. В ТЗ не написано о запрете использовании библиотеки Jetpack compose, а он в корне меняет всю разработку приложения:
	- отстутствие Fragments, View, разметки XML, обратных вызовов для кнопок и т.д.


Техническое задание:

1. Выводится краткая информация о пользователях (ФИО, фотография, адрес, номер телефона) в виде списка, полученная от https://randomuser.me ;

	- JSON получается с помощью Retrofit2 и обрабатывается благодаря Moshi

2. По клику на элемент списка на отдельном экране показывается полная информация о выбранном пользователе;

	- навигация обеспечивается библиотеке Navigation compose;

3. Данные о пользователях не теряются при перезапуске приложения;

	- функционал обеспечивается благодаря библиотеке Room;
   
4. Нажатие на Email, номер телефона, адрес/координаты отправляет пользователя в приложение, которое может обработать эти данные (почта, звонилка, карты);

	- функционал обеспечивается с помощью Intents
   
5. Список пользователей можно обновить принудительно;

	- (!не понятно что здесь имеется ввиду). Мое решение: при нажатии кнопки "Clear users list" происходит очистка базы данных пользователей и следует перересовка списка Users на MainScreen;

6. Пользователю выводятся уведомления о возникших ошибках при загрузке данных или работе с ними.

	- при отстутствии сети интернет или не получении JSON с сервера, пользователь уведомляется о возникших проблемах.


Используемые библиотеки:

Jetpack compose.
Причины выбора: 
Требуется написание меньше кода, быстродействие. 
Код пишется только на Kotlin, полное отсутствие XML разметки.
Полная поддержка Navigation, ViewModel, Livedata.
Красивые приложения благодаря Material Design, темной темы, анимации и многого другого. 
Возможность предварительного просмотра макета прямо в IDE. 
Продвигается Google как новый стандарт написания приложений.
Альтернативы: XML + View system (устаревший подход, согласно Google), Flutter (вообще на другом языке)

Retrofit2.
Причины выбора:
Retrofit быстрее, понятное API, легко сочетается с JSON библиотеками Moshi, Gson, Jackson
Альтернативы: Volley (устарел, нет корутин).

Room
Аналоги: Realm
Причины выбора:
Официальная рекомендация Google (часть Jetpack)
Альтернативы: Realm (NoSQL-база, сложнее чем Room), SQLiteOpenHelper (писать все самому).


Coil
Преимущества:
Написана на Kotlin, использует Coroutine,  понятное API, 
Coil имеет официальную поддержку Compose через AsyncImage, Google в официальной документации рекомендуют Coil.
Альтернативы: Glide (гораздо сложнее), Picasso (устарел, нет поддержки корутин, Jetpack Compose).

Moshi
Причины выбора:
Полностью поддерживает Kotlin data-классы, самый популярный и легкий в изучении по сравнению с аналогами.
Альтернативы: GSON (не рекомендуется потому что написан на java и использует рефлексию), Jackson (очень мощный, но тяжелый, не для андроид разработки).

Navigation Component
Причины выбора:
Интеграция с Jetpack Compose – NavHost работает и с Compose (рекомендация Google)
Альтернативы: Ручная навигация, не очень удобно и подвержено ошибкам

ViewModel + LiveData
Причины выбора:
Интеграция с Room/Compose – работает "по дефолту", (рекомендация Google)
Альтернативы: RxJava (мощный, но сложный, проще использовать корутины), 
StateFlow (более современный, но требует больше кода, посложнее LiveData так, как надо следить за жизненным циклом андроид самому).

Итого:
Эти библиотеки стали стандартом, потому что:
 - Официально поддерживаются Google (кроме Moshi/Coil).
 - Оптимизированы под Kotlin.
 - Минимизируют boilerplate-код (сокращают время разработки и количество возможных ошибок).
 - Хорошо интегрируются друг с другом.


